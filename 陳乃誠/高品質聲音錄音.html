<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>教學錄音工具</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cbb;
            --accent-color: #ff6b6b;
            --light-bg: #f7f9fc;
            --dark-text: #2c3e50;
            --light-text: #ecf0f1;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans TC', '微軟正黑體', sans-serif;
        }

        body {
            background-color: var(--light-bg);
            color: var(--dark-text);
            line-height: 1.6;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--light-text);
            padding: 1.5rem 0;
            text-align: center;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .recorder-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: var(--box-shadow);
            margin-bottom: 2rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }

        button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #b3b3b3;
            cursor: not-allowed;
            transform: none;
        }

        button svg {
            margin-right: 8px;
        }

        .record-btn {
            background-color: var(--accent-color);
        }

        .record-btn:hover {
            background-color: #ff8787;
        }

        .record-btn.recording {
            background-color: #ff3333;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 51, 51, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 51, 51, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 51, 51, 0);
            }
        }

        .timer {
            font-size: 2rem;
            text-align: center;
            margin: 1.5rem 0;
            font-weight: bold;
            color: var(--primary-color);
        }

        .format-select {
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .format-select label {
            font-weight: bold;
        }

        select {
            padding: 0.5rem;
            border-radius: var(--border-radius);
            border: 1px solid #ddd;
            font-size: 1rem;
        }

        .visualizer {
            width: 100%;
            height: 100px;
            background-color: #f0f5ff;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .audio-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .audio-item {
            background-color: var(--light-bg);
            border-radius: var(--border-radius);
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            flex-wrap: wrap;
        }

        .audio-item:hover {
            box-shadow: var(--box-shadow);
        }

        .audio-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .audio-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .audio-controls button {
            min-width: auto;
            padding: 0.5rem;
        }

        .audio-controls a {
            text-decoration: none;
        }

        .status-message {
            text-align: center;
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: var(--border-radius);
            background-color: #e3f2fd;
            display: none;
        }

        .status-message.show {
            display: block;
            animation: fadeIn 0.5s;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 1rem 0;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(74, 111, 165, 0.2);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        footer {
            text-align: center;
            margin-top: 2rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .alert {
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--border-radius);
            background-color: #f8d7da;
            color: #721c24;
            text-align: center;
            display: none;
        }

        .alert.show {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
            }

            .audio-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .audio-controls {
                margin-top: 1rem;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>教學錄音工具</h1>
            <div class="subtitle">輕鬆錄製、轉換與分享您的音頻</div>
        </header>

        <div class="recorder-container">
            <div class="controls">
                <button id="recordButton" class="record-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <circle cx="8" cy="8" r="8"/>
                    </svg>
                    開始錄音
                </button>
                <button id="stopButton" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/>
                    </svg>
                    停止
                </button>
            </div>

            <div class="timer" id="timer">00:00:00</div>
            
            <canvas class="visualizer" id="visualizer"></canvas>
            
            <div class="format-select">
                <label for="format">選擇格式：</label>
                <select id="format">
                    <option value="mp3">MP3</option>
                    <option value="wav">WAV</option>
                    <option value="m4a">M4A (僅 Safari 支援)</option>
                </select>
            </div>

            <div class="status-message" id="statusMessage"></div>
            <div class="alert" id="browserAlert">您的瀏覽器可能不完全支援所有錄音功能。請使用最新版本的 Chrome 或 Firefox 以獲得最佳體驗。</div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>處理中，請稍候...</p>
            </div>
        </div>

        <div class="downloads">
            <h2>已錄製的音頻</h2>
            <div class="audio-list" id="audioList">
                <div id="emptyMessage">目前尚無錄音，請點擊「開始錄音」按鈕開始</div>
            </div>
        </div>

        <footer>
            <p>© 2025 教學錄音工具 | 為教育設計</p>
        </footer>
    </div>

    <!-- 引入 Recorder.js 庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>
    
    <script>
        // DOM 元素
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const timerDisplay = document.getElementById('timer');
        const visualizer = document.getElementById('visualizer');
        const formatSelect = document.getElementById('format');
        const audioList = document.getElementById('audioList');
        const emptyMessage = document.getElementById('emptyMessage');
        const statusMessage = document.getElementById('statusMessage');
        const loading = document.getElementById('loading');
        const browserAlert = document.getElementById('browserAlert');

        // 錄音相關變量
        let mediaRecorder;
        let audioChunks = [];
        let recordingCounter = 0;
        let isRecording = false;
        let startTime;
        let timerInterval;
        let audioContext;
        let analyser;
        let canvasCtx;
        let microphoneStream;

        // 存儲所有錄音的陣列
        let recordings = [];

        // 檢查瀏覽器兼容性
        window.onload = function() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showBrowserAlert(true);
                recordButton.disabled = true;
            } else {
                setupAudioVisualizer();
                setupEventListeners();
                
                // 嘗試讀取本地存儲的錄音
                loadSavedRecordings();
            }
        };

        // 設置事件監聽器
        function setupEventListeners() {
            recordButton.addEventListener('click', toggleRecording);
            stopButton.addEventListener('click', stopRecording);
            
            // 窗口調整大小時重新設置可視化器
            window.addEventListener('resize', function() {
                if (canvasCtx) {
                    visualizer.width = visualizer.offsetWidth;
                    visualizer.height = visualizer.offsetHeight;
                    drawVisualizerStatic();
                }
            });
        }

        // 設置音頻可視化器
        function setupAudioVisualizer() {
            canvasCtx = visualizer.getContext('2d');
            visualizer.width = visualizer.offsetWidth;
            visualizer.height = visualizer.offsetHeight;
            drawVisualizerStatic();
        }

        // 繪製靜態可視化器
        function drawVisualizerStatic() {
            canvasCtx.fillStyle = '#f0f5ff';
            canvasCtx.fillRect(0, 0, visualizer.width, visualizer.height);
            
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#4a6fa5';
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, visualizer.height / 2);
            canvasCtx.lineTo(visualizer.width, visualizer.height / 2);
            canvasCtx.stroke();
        }

        // 繪製動態可視化器
        function drawVisualizer() {
            if (!analyser) return;
            
            requestAnimationFrame(drawVisualizer);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            canvasCtx.fillStyle = '#f0f5ff';
            canvasCtx.fillRect(0, 0, visualizer.width, visualizer.height);
            
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#ff6b6b';
            canvasCtx.beginPath();
            
            const sliceWidth = visualizer.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * visualizer.height / 2;
                
                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            canvasCtx.lineTo(visualizer.width, visualizer.height / 2);
            canvasCtx.stroke();
        }

        // 切換錄音狀態
        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        // 開始錄音
        async function startRecording() {
            try {
                showLoading(false);
                
                // 請求麥克風權限，設定高品質音訊
                const audioConstraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        channelCount: 2,
                        sampleRate: 48000,
                        sampleSize: 24
                    }
                };
                
                microphoneStream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                
                // 設置音頻上下文和分析器，使用更高的取樣率
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000,
                    latencyHint: 'interactive'
                });
                
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(microphoneStream);
                source.connect(analyser);
                analyser.fftSize = 2048;
                
                // 設置媒體記錄器，使用更高的比特率
                const options = { 
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 256000
                };
                
                // 嘗試不同的MIME類型
                let recorderOptions = {};
                if (MediaRecorder.isTypeSupported(options.mimeType)) {
                    recorderOptions = options;
                } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                    recorderOptions = { 
                        mimeType: 'audio/webm', 
                        audioBitsPerSecond: 256000 
                    };
                }
                
                mediaRecorder = new MediaRecorder(microphoneStream, recorderOptions);
                
                // 收集音頻數據
                audioChunks = [];
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                // 錄音結束處理
                mediaRecorder.onstop = processRecording;
                
                // 開始錄音 - 每500毫秒獲取一次數據，減少數據丟失
                mediaRecorder.start(500);
                isRecording = true;
                
                // 開始計時
                startTime = new Date();
                timerInterval = setInterval(updateTimer, 1000);
                
                // 更新 UI
                recordButton.classList.add('recording');
                recordButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <circle cx="8" cy="8" r="8"/>
                    </svg>
                    錄音中...
                `;
                stopButton.disabled = false;
                
                // 啟動可視化
                drawVisualizer();
                
                // 顯示狀態訊息
                showStatusMessage('錄音已開始 (高品質模式)');
                
            } catch (error) {
                console.error('錄音失敗:', error);
                showStatusMessage('無法獲取麥克風權限，請確認您的設備設置', true);
            }
        }

        // 停止錄音
        function stopRecording() {
            if (!mediaRecorder || !isRecording) return;
            
            mediaRecorder.stop();
            isRecording = false;
            
            // 停止計時器
            clearInterval(timerInterval);
            
            // 停止所有軌道
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
            }
            
            // 更新 UI
            recordButton.classList.remove('recording');
            recordButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <circle cx="8" cy="8" r="8"/>
                </svg>
                開始錄音
            `;
            stopButton.disabled = true;
            
            // 重置可視化器
            drawVisualizerStatic();
            
            // 顯示讀取動畫
            showLoading(true);
        }

        // 處理錄音數據
        async function processRecording() {
            try {
                recordingCounter++;
                
                // 創建音頻 Blob
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                
                // 創建錄音對象
                const now = new Date();
                const timestamp = now.toLocaleString('zh-TW');
                const recordingId = `recording_${Date.now()}`;
                
                // 建立錄音資訊
                const recording = {
                    id: recordingId,
                    name: `錄音 ${recordingCounter}`,
                    timestamp: timestamp,
                    blob: audioBlob,
                    url: URL.createObjectURL(audioBlob),
                    size: audioBlob.size,
                    duration: Math.round((now - startTime) / 1000),
                    format: 'webm'
                };
                
                // 添加到錄音列表
                recordings.push(recording);
                
                // 保存到本地存儲
                saveRecordings();
                
                // 添加到頁面
                addRecordingToList(recording);
                
                // 隱藏讀取動畫
                showLoading(false);
                
                // 顯示成功消息
                showStatusMessage('錄音已保存');
                
            } catch (error) {
                console.error('處理錄音失敗:', error);
                showStatusMessage('處理錄音時出錯', true);
                showLoading(false);
            }
        }

        // 添加錄音到列表
        function addRecordingToList(recording) {
            // 隱藏空列表訊息
            emptyMessage.style.display = 'none';
            
            // 格式化時間長度
            const duration = formatDuration(recording.duration);
            
            // 創建元素
            const audioItem = document.createElement('div');
            audioItem.className = 'audio-item';
            audioItem.dataset.id = recording.id;
            audioItem.innerHTML = `
                <div class="audio-info">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#4a6fa5" viewBox="0 0 16 16">
                        <path d="M8 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
                        <path d="M6.94 7a.702.702 0 0 1-.032-.09 1.96 1.96 0 0 1-.017-.125A4 4 0 0 1 16 8c0 .288-.03.57-.088.839l-.197-.148a3 3 0 0 0-1.8-.85A.702.702 0 0 1 13.88 7.8a3 3 0 0 0-1.8-.853.702.702 0 0 1-.032-.087l-.102-.38A1.981 1.981 0 0 0 10.768 7H9.232a1.981 1.981 0 0 0-1.172-.502l-.1.38a.702.702 0 0 1-.033.085 3 3 0 0 0-1.808.86.702.702 0 0 1-.033.085 3 3 0 0 0-1.8.848l-.193.147A4.001 4.001 0 0 1 6.94 7z"/>
                        <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zM1.5 8a6.5 6.5 0 1 1 13 0 6.5 6.5 0 0 1-13 0z"/>
                    </svg>
                    <div>
                        <div><strong>${recording.name}</strong></div>
                        <div>${recording.timestamp} · ${duration}</div>
                    </div>
                </div>
                <audio controls src="${recording.url}" class="audio-player"></audio>
                <div class="audio-controls">
                    <button class="download-mp3-btn" data-id="${recording.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                            <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                        </svg>
                        下載 MP3
                    </button>
                    <button class="download-wav-btn" data-id="${recording.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                            <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                        </svg>
                        下載 WAV
                    </button>
                    <button class="delete-btn" data-id="${recording.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                            <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                        </svg>
                        刪除
                    </button>
                </div>
            `;
            
            // 添加到列表
            audioList.insertBefore(audioItem, audioList.firstChild);
            
            // 添加按鈕事件
            const mp3Btn = audioItem.querySelector('.download-mp3-btn');
            const wavBtn = audioItem.querySelector('.download-wav-btn');
            const deleteBtn = audioItem.querySelector('.delete-btn');
            
            mp3Btn.addEventListener('click', () => convertAndDownload(recording.id, 'mp3'));
            wavBtn.addEventListener('click', () => convertAndDownload(recording.id, 'wav'));
            deleteBtn.addEventListener('click', () => deleteRecording(recording.id));
        }

        // 轉換並下載
        async function convertAndDownload(id, format) {
            try {
                showLoading(true);
                showStatusMessage(`正在轉換為 ${format.toUpperCase()} 格式...`);
                
                // 查找錄音
                const recording = recordings.find(r => r.id === id);
                if (!recording) {
                    throw new Error('找不到錄音');
                }
                
                // 獲取音頻數據
                let audioData;
                let fileName;
                
                if (format === 'mp3') {
                    // 轉換為 MP3
                    audioData = await convertToMp3(recording.blob);
                    fileName = `${recording.name.replace(/[^\w\s]/gi, '')}_${Date.now()}.mp3`;
                } else if (format === 'wav') {
                    // 轉換為 WAV
                    audioData = await convertToWav(recording.blob);
                    fileName = `${recording.name.replace(/[^\w\s]/gi, '')}_${Date.now()}.wav`;
                } else if (format === 'm4a') {
                    // M4A 只在 Safari 支援
                    audioData = recording.blob;
                    fileName = `${recording.name.replace(/[^\w\s]/gi, '')}_${Date.now()}.m4a`;
                } else {
                    // 默認使用原始格式
                    audioData = recording.blob;
                    fileName = `${recording.name.replace(/[^\w\s]/gi, '')}_${Date.now()}.webm`;
                }
                
                // 創建下載連結
                const url = URL.createObjectURL(audioData);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // 釋放 URL
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
                
                showStatusMessage(`已下載為 ${format.toUpperCase()} 格式`);
                
            } catch (error) {
                console.error('下載錯誤:', error);
                showStatusMessage('轉換或下載時出錯', true);
            } finally {
                showLoading(false);
            }
        }

        // 轉換為 MP3
        async function convertToMp3(blob) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 確認是否有 lame.js 庫
                    if (typeof lamejs === 'undefined') {
                        throw new Error('找不到 MP3 轉換庫 (lame.js)');
                    }
                    
                    // 將 blob 轉換為 ArrayBuffer
                    const arrayBuffer = await blob.arrayBuffer();
                    
                    // 建立音訊上下文
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000
                    });
                    
                    // 解碼音訊
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // 獲取左右聲道數據
                    const leftChannel = audioBuffer.getChannelData(0);
                    const rightChannel = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : leftChannel;
                    
                    // 調整音量和品質
                    const sampleRate = audioBuffer.sampleRate;
                    const numSamples = audioBuffer.length;
                    
                    // 創建 MP3 編碼器 - 提高比特率至320kbps提升音質
                    const mp3encoder = new lamejs.Mp3Encoder(audioBuffer.numberOfChannels, sampleRate, 320);
                    const mp3Data = [];
                    
                    // 每次處理的樣本數
                    const sampleBlockSize = 1152;
                    
                    // 處理音頻數據
                    for (let i = 0; i < numSamples; i += sampleBlockSize) {
                        // 創建樣本塊
                        const leftSamples = new Int16Array(sampleBlockSize);
                        const rightSamples = new Int16Array(sampleBlockSize);
                        
                        // 填充樣本塊
                        for (let j = 0; j < sampleBlockSize; j++) {
                            if (i + j < numSamples) {
                                // 從 -1.0..1.0 轉換到 -32768..32767
                                // 加入溫和的壓縮與增益控制，提高音量同時避免失真
                                const gainFactor = 0.9; // 稍微降低以避免失真
                                
                                // 簡易壓縮器，提升較小信號
                                function compress(sample) {
                                    // 溫和的壓縮曲線
                                    return Math.sign(sample) * Math.pow(Math.abs(sample), 0.8) * gainFactor;
                                }
                                
                                leftSamples[j] = compress(leftChannel[i + j]) * 32768;
                                rightSamples[j] = compress(rightChannel[i + j]) * 32768;
                            }
                        }
                        
                        // 如果是單聲道，編碼單聲道數據
                        let mp3buf;
                        if (audioBuffer.numberOfChannels === 1) {
                            mp3buf = mp3encoder.encodeBuffer(leftSamples);
                        } else {
                            // 否則編碼立體聲數據
                            mp3buf = mp3encoder.encodeBuffer(leftSamples, rightSamples);
                        }
                        
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                    }
                    
                    // 完成編碼
                    const mp3buf = mp3encoder.flush();
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                    }
                    
                    // 合併所有 MP3 數據
                    const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
                    resolve(mp3Blob);
                    
                } catch (error) {
                    console.error('MP3 轉換失敗:', error);
                    // 如果轉換失敗，嘗試直接使用原始 blob
                    showStatusMessage('MP3 轉換失敗，使用原始格式下載', true);
                    resolve(blob);
                }
            });
        }

        // 轉換為 WAV
        async function convertToWav(blob) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 將 blob 轉換為 ArrayBuffer
                    const arrayBuffer = await blob.arrayBuffer();
                    
                    // 建立音訊上下文，使用高取樣率
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000
                    });
                    
                    // 解碼音訊
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // WAV 文件格式
                    const numOfChannels = audioBuffer.numberOfChannels;
                    const sampleRate = audioBuffer.sampleRate;
                    const bitsPerSample = 24; // 提高到24位取樣精度
                    const bytesPerSample = bitsPerSample / 8;
                    const blockAlign = numOfChannels * bytesPerSample;
                    const numSamples = audioBuffer.length;
                    const dataSize = numSamples * numOfChannels * bytesPerSample;
                    const bufferSize = 44 + dataSize;
                    
                    // 創建輸出緩衝區
                    const buffer = new ArrayBuffer(bufferSize);
                    const view = new DataView(buffer);
                    
                    // 寫入 WAV 頭
                    // "RIFF" 標識
                    view.setUint8(0, 'R'.charCodeAt(0));
                    view.setUint8(1, 'I'.charCodeAt(0));
                    view.setUint8(2, 'F'.charCodeAt(0));
                    view.setUint8(3, 'F'.charCodeAt(0));
                    
                    // 文件大小（不包括前 8 個字節）
                    view.setUint32(4, bufferSize - 8, true);
                    
                    // "WAVE" 標識
                    view.setUint8(8, 'W'.charCodeAt(0));
                    view.setUint8(9, 'A'.charCodeAt(0));
                    view.setUint8(10, 'V'.charCodeAt(0));
                    view.setUint8(11, 'E'.charCodeAt(0));
                    
                    // "fmt " 子區塊
                    view.setUint8(12, 'f'.charCodeAt(0));
                    view.setUint8(13, 'm'.charCodeAt(0));
                    view.setUint8(14, 't'.charCodeAt(0));
                    view.setUint8(15, ' '.charCodeAt(0));
                    
                    // 子區塊大小
                    view.setUint32(16, 16, true);
                    
                    // 音頻格式（1 為 PCM）
                    view.setUint16(20, 1, true);
                    
                    // 聲道數
                    view.setUint16(22, numOfChannels, true);
                    
                    // 採樣率
                    view.setUint32(24, sampleRate, true);
                    
                    // 字節率 = 採樣率 * 每個樣本字節數
                    view.setUint32(28, sampleRate * blockAlign, true);
                    
                    // 塊對齊 = 聲道數 * 每個樣本字節數
                    view.setUint16(32, blockAlign, true);
                    
                    // 樣本位數
                    view.setUint16(34, bitsPerSample, true);
                    
                    // "data" 子區塊
                    view.setUint8(36, 'd'.charCodeAt(0));
                    view.setUint8(37, 'a'.charCodeAt(0));
                    view.setUint8(38, 't'.charCodeAt(0));
                    view.setUint8(39, 'a'.charCodeAt(0));
                    
                    // 數據大小
                    view.setUint32(40, dataSize, true);
                    
                    // 寫入音頻數據
                    let offset = 44;
                    
                    // 獲取所有聲道數據
                    const channels = [];
                    for (let i = 0; i < numOfChannels; i++) {
                        channels.push(audioBuffer.getChannelData(i));
                    }
                    
                    // 寫入 24 位音頻樣本 (3 字節每樣本)
                    if (bitsPerSample === 24) {
                        for (let i = 0; i < numSamples; i++) {
                            for (let c = 0; c < numOfChannels; c++) {
                                // 獲取樣本值並應用溫和壓縮和增益
                                const gainFactor = 0.9; // 避免失真的增益因子
                                
                                // 簡易壓縮器，提升較小信號
                                function compress(sample) {
                                    // 溫和的壓縮曲線
                                    return Math.sign(sample) * Math.pow(Math.abs(sample), 0.8) * gainFactor;
                                }
                                
                                const sample = compress(channels[c][i]);
                                
                                // 限制範圍到 [-1, 1]
                                const clipped = Math.max(-1, Math.min(1, sample));
                                
                                // 轉換到 24 位
                                const value = clipped < 0 ? clipped * 0x800000 : clipped * 0x7FFFFF;
                                
                                // 寫入 3 字節 (24位)
                                const valueInt = Math.floor(value);
                                view.setUint8(offset++, valueInt & 0xFF);
                                view.setUint8(offset++, (valueInt >> 8) & 0xFF);
                                view.setUint8(offset++, (valueInt >> 16) & 0xFF);
                            }
                        }
                    } else {
                        // 回退到 16 位處理
                        for (let i = 0; i < numSamples; i++) {
                            for (let c = 0; c < numOfChannels; c++) {
                                const sample = Math.max(-1, Math.min(1, channels[c][i]));
                                const value = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                                view.setInt16(offset, value, true);
                                offset += 2;
                            }
                        }
                    }
                    
                    // 創建 WAV Blob
                    const wavBlob = new Blob([buffer], { type: 'audio/wav' });
                    resolve(wavBlob);
                    
                } catch (error) {
                    console.error('WAV 轉換失敗:', error);
                    // 如果轉換失敗，嘗試直接使用原始 blob
                    showStatusMessage('WAV 轉換失敗，使用原始格式下載', true);
                    resolve(blob);
                }
            });
        }

        // 刪除錄音
        function deleteRecording(id) {
            if (confirm('確定要刪除這個錄音嗎？')) {
                // 從陣列中刪除
                const index = recordings.findIndex(r => r.id === id);
                if (index !== -1) {
                    // 釋放 URL
                    URL.revokeObjectURL(recordings[index].url);
                    recordings.splice(index, 1);
                }
                
                // 保存更新
                saveRecordings();
                
                // 從頁面中刪除
                const item = document.querySelector(`.audio-item[data-id="${id}"]`);
                if (item) {
                    item.remove();
                }
                
                // 檢查是否為空列表
                if (recordings.length === 0) {
                    emptyMessage.style.display = 'block';
                }
                
                showStatusMessage('錄音已刪除');
            }
        }

        // 保存錄音到本地存儲
        function saveRecordings() {
            try {
                // 創建可存儲的錄音列表（不包含 Blob 和 URL）
                const storedRecordings = recordings.map(r => ({
                    id: r.id,
                    name: r.name,
                    timestamp: r.timestamp,
                    duration: r.duration,
                    format: r.format,
                    // 本地存儲不能保存 Blob，因此我們將數據轉換為 Base64 字符串
                    data: r.blob ? arrayBufferToBase64(r.blob) : null,
                    type: r.blob ? r.blob.type : 'audio/webm'
                }));
                
                // 保存到本地存儲
                localStorage.setItem('recordings', JSON.stringify(storedRecordings));
                
            } catch (error) {
                console.error('保存錄音失敗:', error);
                showStatusMessage('無法保存錄音到本地存儲', true);
            }
        }

        // 將 Blob 轉換為 Base64 字符串
        function arrayBufferToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const dataUrl = reader.result;
                    const base64 = dataUrl.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // 從本地存儲加載錄音
        async function loadSavedRecordings() {
            try {
                const stored = localStorage.getItem('recordings');
                if (!stored) return;
                
                const storedRecordings = JSON.parse(stored);
                
                // 將存儲的錄音轉換回可用的錄音對象
                for (const r of storedRecordings) {
                    try {
                        // 將 Base64 字符串轉換回 Blob
                        const blob = base64ToBlob(r.data, r.type);
                        
                        // 創建 URL
                        const url = URL.createObjectURL(blob);
                        
                        // 創建錄音對象
                        const recording = {
                            id: r.id,
                            name: r.name,
                            timestamp: r.timestamp,
                            duration: r.duration,
                            format: r.format,
                            blob: blob,
                            url: url,
                            size: blob.size
                        };
                        
                        // 添加到列表
                        recordings.push(recording);
                        
                        // 添加到頁面
                        addRecordingToList(recording);
                        
                        // 更新計數器
                        const match = r.name.match(/錄音 (\d+)/);
                        if (match && parseInt(match[1]) > recordingCounter) {
                            recordingCounter = parseInt(match[1]);
                        }
                    } catch (e) {
                        console.error('載入錄音失敗:', e);
                    }
                }
                
            } catch (error) {
                console.error('從本地存儲載入錄音失敗:', error);
            }
        }

        // 將 Base64 字符串轉換為 Blob
        function base64ToBlob(base64, type) {
            const binaryString = window.atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return new Blob([bytes], { type: type });
        }

        // 顯示狀態訊息
        function showStatusMessage(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.backgroundColor = isError ? '#ffebee' : '#e3f2fd';
            statusMessage.style.color = isError ? '#c62828' : '#0d47a1';
            statusMessage.classList.add('show');
            
            setTimeout(() => {
                statusMessage.classList.remove('show');
            }, 3000);
        }

        // 顯示瀏覽器提示
        function showBrowserAlert(show) {
            if (show) {
                browserAlert.classList.add('show');
            } else {
                browserAlert.classList.remove('show');
            }
        }

        // 顯示載入動畫
        function showLoading(show) {
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        // 更新計時器
        function updateTimer() {
            const now = new Date();
            const diff = now - startTime;
            
            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            
            const formattedTime = 
                String(hours).padStart(2, '0') + ':' +
                String(minutes).padStart(2, '0') + ':' +
                String(seconds).padStart(2, '0');
            
            timerDisplay.textContent = formattedTime;
        }

        // 格式化時間長度
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            } else {
                return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
            }
        }
    </script>
</body>
</html>